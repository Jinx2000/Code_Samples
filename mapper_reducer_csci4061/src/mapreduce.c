#include "mapreduce.h"

int main(int argc, char *argv[]) {
	
	if(argc < 4) {
		printf("Less number of arguments.\n");
		printf("./mapreduce #mappers #reducers inputFile\n");
		exit(0);
	}

	// ###### DO NOT REMOVE ######
	int nMappers 	= strtol(argv[1], NULL, 10);
	int nReducers 	= strtol(argv[2], NULL, 10);
	char *inputFile = argv[3];

	// ###### DO NOT REMOVE ######
	bookeepingCode();

	// ###### DO NOT REMOVE ######
	pid_t pid = fork();
	if(pid == 0){
		//send chunks of data to the mappers in RR fashion
		sendChunkData(inputFile, nMappers);
		//printf("did we get here?");
		exit(0);
	}
	sleep(1);


	// To do
	// spawn mappers processes and run 'mapper' executable using exec
	for (int i = 1; i <= nMappers; i++) {
		pid_t mapper_pid = fork();
		// check fork():
		if (mapper_pid == 0){
			char temp[20]; // used to convert int i to char*
			sprintf(temp, "%d", i);
			char* args[] = {"mapper", temp, NULL};
			int test = execv(*args, args);
			// check exec():
			if (test == -1) {
				printf("Error executing execv()\n");
				exit(1);
			}
			exit(0);
		} else if (mapper_pid < 0){
			printf("Failure creating child process (error number: %d)\n", errno);
		}
	}


	// To do
	// wait for all children to complete execution
	int i = 0;
	pid_t wait_pid;
	int status;
	while (i <= nMappers) { // why would I have to wait for (n + 1) process?
  		wait_pid = wait(NULL);
		// check wait():
		if (wait_pid == -1) {
			printf("Wrong return value for wait(), check the code\n");
			exit(1);
		}
		i++;
	}






	// ###### DO NOT REMOVE ######
    // shuffle sends the word.txt files generated by mapper 
    // to reducer based on a hash function
	pid = fork();
	if(pid == 0){
		shuffle(nMappers, nReducers);
		exit(0);	wait(NULL);
	}

	// To do
	// spawn reducer processes and run 'reducer' executable using exec
	for (int i = 1; i <= nReducers; i++) {
		pid_t reducer_pid = fork();
		// check fork():
		if (reducer_pid == 0){
			char temp[20];
			sprintf(temp, "%d", i);
			char* args[] = {"reducer", temp, NULL};
			int test = execv(*args, args);
			// check exec():
			if (test == -1) {
				printf("Error executing execv()\n");
				exit(1);
			}
			exit(0);
		} else if (reducer_pid < 0){
			printf("Failure creating child process (error number: %d)\n", errno);
			exit(1);
		}
	}

	// To do
	// wait for all children to complete execution
	i = 0; // re-initial i.
	while (i <= nReducers) { // why would I have to wait for (n + 1) process?
  		wait_pid = wait(NULL);
		  // check wait():
		if (wait_pid == -1) {
			printf("Wrong return value for wait(), check the code\n");
			exit(1);
		}
		i++;
	}
	return 0;
}